# FinOps Tag Compliance MCP Server - Regression Test Suite
#
# Runs against the HTTP transport at localhost:8080.
# Start the server first: python run_server.py
#
# Usage:
#   cd tests/regression
#   npx promptfoo@latest eval
#   npx promptfoo@latest view    # Open results in browser
#
# Environment variables:
#   MCP_SERVER_URL  - Server URL (default: http://localhost:8080)
#   MCP_API_KEY     - API key if auth is enabled (optional)
#   MCP_TIMEOUT     - Request timeout in seconds (default: 120)

description: "FinOps Tag Compliance MCP Server - Regression Tests"

providers:
  - id: "python:mcp_provider.py"
    label: "MCP HTTP Provider"

# The prompt template wraps each test case into a JSON tool call
prompts:
  - "{{tool_call}}"

defaultTest:
  options:
    provider:
      id: "python:mcp_provider.py"

tests:
  # ===========================================================================
  # Tool 1: check_tag_compliance
  # ===========================================================================

  # 1.1 - Basic compliance check with specific resource types
  - description: "check_tag_compliance - specific resource types"
    vars:
      tool_call: |
        {"name": "check_tag_compliance", "arguments": {"resource_types": ["ec2:instance", "s3:bucket"], "severity": "all"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.compliance_score !== undefined
            && typeof data.compliance_score === 'number'
            && data.compliance_score >= 0
            && data.compliance_score <= 1;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.total_resources !== undefined
            && typeof data.total_resources === 'number'
            && data.total_resources >= 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.compliant_resources !== undefined
            && data.compliant_resources <= data.total_resources;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.violations);
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.scan_timestamp !== undefined
            && data.scan_timestamp.length > 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.cost_attribution_gap !== undefined
            && typeof data.cost_attribution_gap === 'number';

  # 1.2 - Compliance check returns multi-region metadata
  - description: "check_tag_compliance - has region metadata"
    vars:
      tool_call: |
        {"name": "check_tag_compliance", "arguments": {"resource_types": ["ec2:instance"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // Multi-region scan should include region_metadata
          if (data.region_metadata) {
            return data.region_metadata.total_regions > 0
              && Array.isArray(data.region_metadata.successful_regions);
          }
          // Single-region scan is also acceptable
          return true;

  # 1.3 - Compliance check with severity filter
  - description: "check_tag_compliance - errors_only filter"
    vars:
      tool_call: |
        {"name": "check_tag_compliance", "arguments": {"resource_types": ["ec2:instance"], "severity": "errors_only"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // All violations should be errors when filtered
          return data.violations.every(v => v.severity === 'error' || v.severity === 'ERROR');

  # 1.4 - Compliance check violation structure
  - description: "check_tag_compliance - violation structure"
    vars:
      tool_call: |
        {"name": "check_tag_compliance", "arguments": {"resource_types": ["s3:bucket"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // If there are violations, check their structure
          if (data.violations.length > 0) {
            const v = data.violations[0];
            return v.resource_id !== undefined
              && v.resource_type !== undefined
              && v.violation_type !== undefined
              && v.tag_name !== undefined
              && v.severity !== undefined;
          }
          return true;

  # ===========================================================================
  # Tool 2: find_untagged_resources
  # ===========================================================================

  # 2.1 - Basic untagged resource scan
  - description: "find_untagged_resources - basic scan"
    vars:
      tool_call: |
        {"name": "find_untagged_resources", "arguments": {"resource_types": ["ec2:instance", "s3:bucket"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.total_untagged !== undefined
            && typeof data.total_untagged === 'number'
            && data.total_untagged >= 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.resources);
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.scan_timestamp !== undefined;

  # 2.2 - Untagged resources with cost estimates
  - description: "find_untagged_resources - with costs"
    vars:
      tool_call: |
        {"name": "find_untagged_resources", "arguments": {"resource_types": ["ec2:instance"], "include_costs": true}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // When include_costs is true, total_monthly_cost should be present
          return data.total_monthly_cost !== undefined
            && typeof data.total_monthly_cost === 'number';

  # 2.3 - Untagged resource structure
  - description: "find_untagged_resources - resource structure"
    vars:
      tool_call: |
        {"name": "find_untagged_resources", "arguments": {"resource_types": ["s3:bucket"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          if (data.resources.length > 0) {
            const r = data.resources[0];
            return r.resource_id !== undefined
              && r.resource_type !== undefined
              && r.region !== undefined
              && r.arn !== undefined
              && typeof r.current_tags === 'object'
              && Array.isArray(r.missing_required_tags);
          }
          return true;

  # 2.4 - Untagged resources with region filter
  - description: "find_untagged_resources - region filter"
    vars:
      tool_call: |
        {"name": "find_untagged_resources", "arguments": {"resource_types": ["ec2:instance"], "regions": ["us-east-1"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.total_untagged !== undefined
            && Array.isArray(data.resources);

  # ===========================================================================
  # Tool 3: validate_resource_tags
  # ===========================================================================

  # 3.1 - Validate with valid ARN format
  - description: "validate_resource_tags - valid ARN"
    vars:
      tool_call: |
        {"name": "validate_resource_tags", "arguments": {"resource_arns": ["arn:aws:s3:::my-test-bucket"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.total_resources !== undefined
            && data.compliant_resources !== undefined
            && data.non_compliant_resources !== undefined;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.results);
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.validation_timestamp !== undefined;

  # 3.2 - Validate resource result structure
  - description: "validate_resource_tags - result structure"
    vars:
      tool_call: |
        {"name": "validate_resource_tags", "arguments": {"resource_arns": ["arn:aws:s3:::my-test-bucket"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          if (data.results.length > 0) {
            const r = data.results[0];
            return r.resource_arn !== undefined
              && r.resource_type !== undefined
              && r.is_compliant !== undefined
              && Array.isArray(r.violations)
              && typeof r.current_tags === 'object';
          }
          return true;

  # 3.3 - Validate counts are consistent
  - description: "validate_resource_tags - consistent counts"
    vars:
      tool_call: |
        {"name": "validate_resource_tags", "arguments": {"resource_arns": ["arn:aws:s3:::my-test-bucket"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.total_resources === data.compliant_resources + data.non_compliant_resources;

  # ===========================================================================
  # Tool 4: get_cost_attribution_gap
  # ===========================================================================

  # 4.1 - Basic cost attribution gap
  - description: "get_cost_attribution_gap - basic"
    vars:
      tool_call: |
        {"name": "get_cost_attribution_gap", "arguments": {"resource_types": ["ec2:instance", "s3:bucket"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.total_spend !== undefined
            && typeof data.total_spend === 'number'
            && data.total_spend >= 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.attributable_spend !== undefined
            && data.attribution_gap !== undefined
            && data.attribution_gap_percentage !== undefined;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.scan_timestamp !== undefined;

  # 4.2 - Cost attribution gap with group_by
  - description: "get_cost_attribution_gap - group by resource_type"
    vars:
      tool_call: |
        {"name": "get_cost_attribution_gap", "arguments": {"resource_types": ["ec2:instance", "s3:bucket"], "group_by": "resource_type"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // When group_by is set, breakdown should exist
          if (data.breakdown) {
            return typeof data.breakdown === 'object';
          }
          return true;

  # 4.3 - Cost attribution gap math consistency
  - description: "get_cost_attribution_gap - math consistency"
    vars:
      tool_call: |
        {"name": "get_cost_attribution_gap", "arguments": {"resource_types": ["ec2:instance"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // attribution_gap should equal total_spend - attributable_spend (within rounding)
          const expectedGap = data.total_spend - data.attributable_spend;
          return Math.abs(data.attribution_gap - expectedGap) < 0.01;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // Percentage should be between 0 and 100
          return data.attribution_gap_percentage >= 0
            && data.attribution_gap_percentage <= 100;

  # ===========================================================================
  # Tool 5: suggest_tags
  # ===========================================================================

  # 5.1 - Tag suggestion for S3 bucket
  - description: "suggest_tags - S3 bucket"
    vars:
      tool_call: |
        {"name": "suggest_tags", "arguments": {"resource_arn": "arn:aws:s3:::my-test-bucket"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.resource_arn !== undefined
            && data.resource_type !== undefined;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.suggestions)
            && typeof data.current_tags === 'object';

  # 5.2 - Tag suggestion structure
  - description: "suggest_tags - suggestion structure"
    vars:
      tool_call: |
        {"name": "suggest_tags", "arguments": {"resource_arn": "arn:aws:s3:::my-test-bucket"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          if (data.suggestions && data.suggestions.length > 0) {
            const s = data.suggestions[0];
            return s.tag_name !== undefined
              && s.suggested_value !== undefined
              && s.confidence !== undefined
              && typeof s.confidence === 'number'
              && s.confidence >= 0
              && s.confidence <= 1;
          }
          return true;

  # ===========================================================================
  # Tool 6: get_tagging_policy
  # ===========================================================================

  # 6.1 - Returns tagging policy
  - description: "get_tagging_policy - returns policy"
    vars:
      tool_call: |
        {"name": "get_tagging_policy", "arguments": {}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.required_tags)
            && data.required_tags.length > 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.optional_tags);

  # 6.2 - Required tag structure
  - description: "get_tagging_policy - required tag structure"
    vars:
      tool_call: |
        {"name": "get_tagging_policy", "arguments": {}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          if (data.required_tags.length > 0) {
            const tag = data.required_tags[0];
            return tag.name !== undefined
              && tag.description !== undefined;
          }
          return true;

  # 6.3 - Known required tags present
  - description: "get_tagging_policy - known tags exist"
    vars:
      tool_call: |
        {"name": "get_tagging_policy", "arguments": {}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          const tagNames = data.required_tags.map(t => t.name);
          // These are the standard required tags from tagging_policy.json
          return tagNames.includes('Environment')
            && tagNames.includes('Owner')
            && tagNames.includes('Application');

  # 6.4 - Policy is idempotent (same result on repeated calls)
  - description: "get_tagging_policy - idempotent"
    vars:
      tool_call: |
        {"name": "get_tagging_policy", "arguments": {}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // Basic structural check - policy should always return same shape
          return typeof data === 'object'
            && Array.isArray(data.required_tags)
            && Array.isArray(data.optional_tags);

  # ===========================================================================
  # Tool 7: generate_compliance_report
  # ===========================================================================

  # 7.1 - JSON report
  - description: "generate_compliance_report - JSON format"
    vars:
      tool_call: |
        {"name": "generate_compliance_report", "arguments": {"resource_types": ["ec2:instance"], "format": "json"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.format !== undefined
            && data.report_data !== undefined;

  # 7.2 - Markdown report
  - description: "generate_compliance_report - Markdown format"
    vars:
      tool_call: |
        {"name": "generate_compliance_report", "arguments": {"resource_types": ["ec2:instance"], "format": "markdown"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.format === 'markdown'
            && data.report_data !== undefined;

  # 7.3 - CSV report
  - description: "generate_compliance_report - CSV format"
    vars:
      tool_call: |
        {"name": "generate_compliance_report", "arguments": {"resource_types": ["ec2:instance"], "format": "csv"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.format === 'csv'
            && data.report_data !== undefined;

  # 7.4 - Report with recommendations
  - description: "generate_compliance_report - with recommendations"
    vars:
      tool_call: |
        {"name": "generate_compliance_report", "arguments": {"resource_types": ["ec2:instance"], "format": "json", "include_recommendations": true}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.report_data !== undefined;

  # ===========================================================================
  # Tool 8: get_violation_history
  # ===========================================================================

  # 8.1 - Basic history retrieval
  - description: "get_violation_history - basic"
    vars:
      tool_call: |
        {"name": "get_violation_history", "arguments": {"days_back": 30, "group_by": "day"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.period_days !== undefined
            && typeof data.period_days === 'number';
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.data_points);

  # 8.2 - History with week grouping
  - description: "get_violation_history - weekly grouping"
    vars:
      tool_call: |
        {"name": "get_violation_history", "arguments": {"days_back": 90, "group_by": "week"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.period_days !== undefined
            && Array.isArray(data.data_points);

  # 8.3 - History data point structure
  - description: "get_violation_history - data point structure"
    vars:
      tool_call: |
        {"name": "get_violation_history", "arguments": {"days_back": 30}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          if (data.data_points && data.data_points.length > 0) {
            const dp = data.data_points[0];
            return dp.timestamp !== undefined
              && dp.compliance_score !== undefined;
          }
          // Empty history is acceptable (no scans stored yet)
          return true;

  # 8.4 - History with month grouping
  - description: "get_violation_history - monthly grouping"
    vars:
      tool_call: |
        {"name": "get_violation_history", "arguments": {"days_back": 90, "group_by": "month"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.period_days !== undefined;

  # ===========================================================================
  # Error handling & edge cases
  # ===========================================================================

  # E.1 - Invalid tool name returns error
  - description: "error - invalid tool name"
    vars:
      tool_call: |
        {"name": "nonexistent_tool", "arguments": {}}
    assert:
      - type: javascript
        value: |
          // Should get an error response (HTTP error or MCP error)
          const data = JSON.parse(output);
          return data.error !== undefined || data.detail !== undefined;

  # E.2 - Invalid severity value
  - description: "error - invalid severity"
    vars:
      tool_call: |
        {"name": "check_tag_compliance", "arguments": {"resource_types": ["ec2:instance"], "severity": "INVALID_VALUE"}}
    assert:
      - type: is-json
        # Should still return a response (may use default severity or return error)

  # E.3 - Empty resource_types
  - description: "edge case - empty resource types"
    vars:
      tool_call: |
        {"name": "check_tag_compliance", "arguments": {"resource_types": []}}
    assert:
      - type: is-json
        # Should handle gracefully

  # E.4 - Invalid ARN format
  - description: "error - invalid ARN format"
    vars:
      tool_call: |
        {"name": "validate_resource_tags", "arguments": {"resource_arns": ["not-a-valid-arn"]}}
    assert:
      - type: is-json
        # Should handle gracefully (validation error or empty results)

  # ===========================================================================
  # Performance & response time checks
  # ===========================================================================

  # P.1 - Policy retrieval should be fast (no AWS calls)
  - description: "performance - get_tagging_policy is fast"
    vars:
      tool_call: |
        {"name": "get_tagging_policy", "arguments": {}}
    assert:
      - type: is-json
      - type: latency
        threshold: 5000  # Should complete in under 5 seconds

  # P.2 - History retrieval should be fast (local DB only)
  - description: "performance - get_violation_history is fast"
    vars:
      tool_call: |
        {"name": "get_violation_history", "arguments": {"days_back": 7}}
    assert:
      - type: is-json
      - type: latency
        threshold: 5000  # Should complete in under 5 seconds

  # ===========================================================================
  # Tool 9: generate_custodian_policy
  # ===========================================================================

  # 9.1 - Basic Custodian policy generation with specific resource types
  - description: "generate_custodian_policy - specific resource types"
    vars:
      tool_call: |
        {"name": "generate_custodian_policy", "arguments": {"resource_types": ["ec2:instance", "s3:bucket"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.policies)
            && typeof data.total_policies === 'number'
            && data.total_policies >= 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return typeof data.combined_yaml === 'string';
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.resource_types_covered)
            && Array.isArray(data.target_tags);
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return typeof data.dry_run === 'boolean';

  # 9.2 - Custodian policy structure for individual policies
  - description: "generate_custodian_policy - policy structure"
    vars:
      tool_call: |
        {"name": "generate_custodian_policy", "arguments": {"resource_types": ["ec2:instance"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          if (data.policies.length > 0) {
            const p = data.policies[0];
            return p.name !== undefined
              && p.resource_type !== undefined
              && p.yaml_content !== undefined
              && p.description !== undefined
              && typeof p.filter_count === 'number'
              && p.action_type !== undefined;
          }
          return true;

  # 9.3 - Custodian policy dry_run mode produces notify actions
  - description: "generate_custodian_policy - dry_run=true produces notify"
    vars:
      tool_call: |
        {"name": "generate_custodian_policy", "arguments": {"resource_types": ["ec2:instance"], "dry_run": true}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // dry_run should be true and policies should have notify action_type
          if (data.policies.length > 0) {
            return data.dry_run === true
              && data.policies.every(p => p.action_type === 'notify');
          }
          return data.dry_run === true;

  # 9.4 - Custodian policy total_policies matches policies array length
  - description: "generate_custodian_policy - total_policies consistent"
    vars:
      tool_call: |
        {"name": "generate_custodian_policy", "arguments": {"resource_types": ["ec2:instance", "rds:db"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.total_policies === data.policies.length;

  # ===========================================================================
  # Tool 10: generate_openops_workflow
  # ===========================================================================

  # 10.1 - Basic OpenOps workflow generation
  - description: "generate_openops_workflow - basic notify strategy"
    vars:
      tool_call: |
        {"name": "generate_openops_workflow", "arguments": {"resource_types": ["ec2:instance"], "remediation_strategy": "notify"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.workflow_name !== undefined
            && typeof data.workflow_name === 'string'
            && data.workflow_name.length > 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return typeof data.yaml_content === 'string'
            && data.yaml_content.length > 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.remediation_strategy === 'notify';

  # 10.2 - OpenOps workflow step structure
  - description: "generate_openops_workflow - step structure"
    vars:
      tool_call: |
        {"name": "generate_openops_workflow", "arguments": {"resource_types": ["ec2:instance"], "remediation_strategy": "report"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.steps)
            && typeof data.step_count === 'number'
            && data.step_count >= 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          if (data.steps.length > 0) {
            const s = data.steps[0];
            return s.name !== undefined
              && s.action !== undefined;
          }
          return true;

  # 10.3 - OpenOps workflow step_count matches steps array
  - description: "generate_openops_workflow - step_count consistent"
    vars:
      tool_call: |
        {"name": "generate_openops_workflow", "arguments": {"resource_types": ["ec2:instance"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.step_count === data.steps.length;

  # 10.4 - OpenOps workflow has resource_types in response
  - description: "generate_openops_workflow - resource_types in response"
    vars:
      tool_call: |
        {"name": "generate_openops_workflow", "arguments": {"resource_types": ["ec2:instance", "rds:db"], "remediation_strategy": "auto_tag"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.resource_types)
            && data.resource_types.length > 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.description !== undefined
            && typeof data.description === 'string';

  # ===========================================================================
  # Tool 11: schedule_compliance_audit
  # ===========================================================================

  # 11.1 - Basic daily schedule creation
  - description: "schedule_compliance_audit - daily schedule"
    vars:
      tool_call: |
        {"name": "schedule_compliance_audit", "arguments": {"schedule": "daily", "time": "09:00"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.schedule_id !== undefined
            && typeof data.schedule_id === 'string'
            && data.schedule_id.startsWith('audit-sched-');
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.status === 'created';
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.schedule_type === 'daily'
            && data.time === '09:00';

  # 11.2 - Schedule with full parameters
  - description: "schedule_compliance_audit - full parameters"
    vars:
      tool_call: |
        {"name": "schedule_compliance_audit", "arguments": {"schedule": "weekly", "time": "14:30", "timezone_str": "US/Eastern", "resource_types": ["ec2:instance"], "recipients": ["admin@example.com"], "notification_format": "markdown"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.schedule_type === 'weekly'
            && data.time === '14:30'
            && data.timezone === 'US/Eastern';
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.cron_expression !== undefined
            && typeof data.cron_expression === 'string'
            && data.cron_expression.length > 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.next_run !== undefined
            && typeof data.next_run === 'string'
            && data.next_run.length > 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.message !== undefined
            && typeof data.message === 'string';

  # 11.3 - Schedule has correct cron format for monthly
  - description: "schedule_compliance_audit - monthly cron expression"
    vars:
      tool_call: |
        {"name": "schedule_compliance_audit", "arguments": {"schedule": "monthly", "time": "08:00"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // Monthly cron: "0 8 1 * *" (minute hour day-of-month * *)
          return data.schedule_type === 'monthly'
            && data.cron_expression !== undefined
            && data.cron_expression.includes('1 *');

  # ===========================================================================
  # Tool 12: detect_tag_drift
  # ===========================================================================

  # 12.1 - Basic drift detection with defaults
  - description: "detect_tag_drift - basic detection"
    vars:
      tool_call: |
        {"name": "detect_tag_drift", "arguments": {}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.drift_detected)
            && typeof data.total_drifts === 'number'
            && data.total_drifts >= 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return typeof data.resources_analyzed === 'number'
            && data.resources_analyzed >= 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return typeof data.lookback_days === 'number'
            && data.lookback_days >= 1
            && data.lookback_days <= 90;

  # 12.2 - Drift detection with specific resource types
  - description: "detect_tag_drift - specific resource types"
    vars:
      tool_call: |
        {"name": "detect_tag_drift", "arguments": {"resource_types": ["ec2:instance"], "lookback_days": 14}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.lookback_days === 14;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.scan_timestamp !== undefined;

  # 12.3 - Drift detection summary structure
  - description: "detect_tag_drift - summary structure"
    vars:
      tool_call: |
        {"name": "detect_tag_drift", "arguments": {"resource_types": ["ec2:instance"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // summary should have added, removed, changed counts
          return typeof data.summary === 'object'
            && typeof data.summary.added === 'number'
            && typeof data.summary.removed === 'number'
            && typeof data.summary.changed === 'number';

  # 12.4 - Drift detection total_drifts matches drift_detected length
  - description: "detect_tag_drift - total_drifts consistent"
    vars:
      tool_call: |
        {"name": "detect_tag_drift", "arguments": {}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.total_drifts === data.drift_detected.length;

  # 12.5 - Drift entry structure
  - description: "detect_tag_drift - drift entry structure"
    vars:
      tool_call: |
        {"name": "detect_tag_drift", "arguments": {"resource_types": ["ec2:instance", "s3:bucket"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          if (data.drift_detected.length > 0) {
            const d = data.drift_detected[0];
            return d.resource_arn !== undefined
              && d.resource_id !== undefined
              && d.resource_type !== undefined
              && d.tag_key !== undefined
              && d.drift_type !== undefined
              && ['added', 'removed', 'changed'].includes(d.drift_type)
              && d.severity !== undefined
              && ['critical', 'warning', 'info'].includes(d.severity);
          }
          // No drifts detected is acceptable
          return true;

  # ===========================================================================
  # Tool 13: export_violations_csv
  # ===========================================================================

  # 13.1 - Basic CSV export with defaults
  - description: "export_violations_csv - basic export"
    vars:
      tool_call: |
        {"name": "export_violations_csv", "arguments": {"resource_types": ["ec2:instance"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.csv_data !== undefined
            && typeof data.csv_data === 'string';
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return typeof data.row_count === 'number'
            && data.row_count >= 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return typeof data.column_count === 'number'
            && data.column_count > 0;

  # 13.2 - CSV export has expected metadata fields
  - description: "export_violations_csv - metadata fields"
    vars:
      tool_call: |
        {"name": "export_violations_csv", "arguments": {"resource_types": ["s3:bucket"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return Array.isArray(data.columns)
            && data.columns.length > 0;
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.format === 'csv';
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return typeof data.filters_applied === 'object';
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.export_timestamp !== undefined;

  # 13.3 - CSV data contains header row matching columns
  - description: "export_violations_csv - CSV header matches columns"
    vars:
      tool_call: |
        {"name": "export_violations_csv", "arguments": {"resource_types": ["ec2:instance"]}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // CSV header line should contain the column names
          if (data.csv_data && data.csv_data.length > 0) {
            const headerLine = data.csv_data.split('\n')[0];
            // Check that at least some expected columns appear in the header
            return data.columns.every(col => headerLine.includes(col));
          }
          return true;

  # 13.4 - CSV export column_count matches columns array length
  - description: "export_violations_csv - column_count consistent"
    vars:
      tool_call: |
        {"name": "export_violations_csv", "arguments": {"resource_types": ["ec2:instance"], "severity": "errors_only"}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.column_count === data.columns.length;

  # ===========================================================================
  # Tool 14: import_aws_tag_policy
  # ===========================================================================

  # 14.1 - List available policies (no policy_id)
  - description: "import_aws_tag_policy - list policies"
    vars:
      tool_call: |
        {"name": "import_aws_tag_policy", "arguments": {}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // Should return a status field
          return data.status !== undefined
            && typeof data.status === 'string';
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // status should be 'listed' or 'error' (depending on AWS Organizations access)
          return ['listed', 'error'].includes(data.status);
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.message !== undefined
            && typeof data.message === 'string'
            && data.message.length > 0;

  # 14.2 - Response has conversion_timestamp
  - description: "import_aws_tag_policy - has timestamp"
    vars:
      tool_call: |
        {"name": "import_aws_tag_policy", "arguments": {}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          return data.conversion_timestamp !== undefined;

  # 14.3 - When listing, available_policies is present (or error status)
  - description: "import_aws_tag_policy - list structure"
    vars:
      tool_call: |
        {"name": "import_aws_tag_policy", "arguments": {}}
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          // If status is 'listed', available_policies should be an array
          if (data.status === 'listed') {
            return Array.isArray(data.available_policies);
          }
          // If status is 'error', message should explain the issue
          if (data.status === 'error') {
            return data.message.length > 0;
          }
          return true;

  # 14.4 - Import with invalid policy_id returns error gracefully
  - description: "import_aws_tag_policy - invalid policy_id"
    vars:
      tool_call: |
        {"name": "import_aws_tag_policy", "arguments": {"policy_id": "p-invalid-does-not-exist"}}
    assert:
      - type: is-json
        # Should return a response (error or exception) not crash

  # ===========================================================================
  # Phase 2 error handling & edge cases
  # ===========================================================================

  # E2.1 - Custodian policy with empty resource_types handled gracefully
  - description: "error - generate_custodian_policy empty resource_types"
    vars:
      tool_call: |
        {"name": "generate_custodian_policy", "arguments": {"resource_types": []}}
    assert:
      - type: is-json
        # Should handle gracefully (error or empty results)

  # E2.2 - Invalid lookback_days for detect_tag_drift
  - description: "error - detect_tag_drift invalid lookback_days"
    vars:
      tool_call: |
        {"name": "detect_tag_drift", "arguments": {"lookback_days": 999}}
    assert:
      - type: is-json
        # Should return validation error

  # E2.3 - Invalid schedule type for schedule_compliance_audit
  - description: "error - schedule_compliance_audit invalid schedule"
    vars:
      tool_call: |
        {"name": "schedule_compliance_audit", "arguments": {"schedule": "hourly"}}
    assert:
      - type: is-json
        # Should return validation error

  # ===========================================================================
  # Phase 2 performance checks
  # ===========================================================================

  # P2.1 - Schedule creation should be fast (no AWS calls)
  - description: "performance - schedule_compliance_audit is fast"
    vars:
      tool_call: |
        {"name": "schedule_compliance_audit", "arguments": {"schedule": "daily"}}
    assert:
      - type: is-json
      - type: latency
        threshold: 5000  # Should complete in under 5 seconds

  # P2.2 - Custodian policy generation should be fast (no AWS calls, policy only)
  - description: "performance - generate_custodian_policy is fast"
    vars:
      tool_call: |
        {"name": "generate_custodian_policy", "arguments": {"resource_types": ["ec2:instance"]}}
    assert:
      - type: is-json
      - type: latency
        threshold: 10000  # Should complete in under 10 seconds
